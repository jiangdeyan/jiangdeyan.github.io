---
layout:     post
title:      JNI官方文档翻译
category: blog
description: 英语小菜，尝试翻译一下。
---

## 介绍

 
[原文地址][1]


------


## 第一章

本章介绍Java Native Interface（JNI）。JNI是一种本地编程接口。它允许运行在Java虚拟机（JVM）中的Java代码与其他编程语言比如C、C++、汇编等编写的库或者应用进行交互操作。

JNI最大的好处就是不影响JVM底层的程序实现。因此，Java虚拟机的提供商可以在不影响虚拟机其他部分的情况下增加对JNI的支持。程序员可以只编写一个版本的本地库或者应用就可以在所有支持JNI的Java虚拟机上。
本章包含以下主题：
-  JNI概述
-  背景
-  宗旨
-  JNI方法
-  JNI编程
-  改动

###JNI概述 

 当你用纯Java编写应用的时候，会出现Java本身无法提供满足应用需求的情况。在程序不能用纯Java进行编写时，程序员通过使用JNI编写Java本地代码（*Java native methods*）来处理这种情况。

以下列举了你需要使用JNI的情况：

- 标准Java库无法支持应用所需要的与平台相关的特征。
- 你已经有一个用其他语言编写的库，并希望通过JNI时Java代码可以调用。
- 你想用低级别的语言譬如汇编，来实现一个对时序要求严格的一小段代码。

通过使用JNI，你可以本地方法实现：

-  创建，检查和更新Java对象（包括数组和字符串）
- 调用Java方法
- 捕获和抛出异常
- 加载类和获取类的信息
- 执行运行时类型检查

你也可以通过JNI的调用API（*Invocation API*）使得任意的本地应用嵌入到Java虚拟机中。这使得程序员可以轻易地使已经存在的应用Java化，而不需要改动虚拟机源码。

###历史背景
目前，不同供应商提供的虚拟机提供不同的本地方法接口。这些不同的方法使得程序员不得不在一个平台上编写，维护和部署不同版本的本地方法库。

我们简单地列举一些存在的本地方法库，比如：

- JDK 1.0本地方法接口（*JDK 1.0 native method interface*）
- Netscape的Java运行时接口（*Netscape’s Java Runtime Interface*）
- 微软Raw Native接口和JAVA/COM接口（*Microsoft’s Raw Native Interface and Java/COM interface*）

####JDK 1.0本地方法接口
JDK 1.0发布了本地方法接口。但是，有两个原因导致这个接口不被其他Java虚拟机接受。

首先，本地代码通过C语言的结构体成员来访问Java对象的字段，然而Java语言说明书（*Java Language Specification*）没有定义对象在内存中如何存储。如果一个Java虚拟机对对象的存储有差异，那么程序员不得不重新编译本地方法库。

其次，JDK 1.0的本地方法接口依赖于一个”谨慎“的垃圾回收器，比如无限制的使用未处理（？）的宏使它必须谨慎的扫描本地栈。

####Java运行时接口

Netscape提出了Java运行时接口（JRI），一个Java虚拟机提供的通用接口服务。JRI在设计时考虑了移植性问题，它很少依赖于Java虚拟机的底层实现细节，JRI可以处理很多问题（？），包括本地方法，调试，反射，嵌入（调用）等等。

####Raw Native接口和Java/COM接口

微软Java虚拟机支持两种本地方法接口。在底层，提供一个高效率的Raw Native接口（RNI）。RNI可以高度源码级别的向下兼容JDK本地方法接口，尽管它与JDK本地方法接口有很大的不同。本地代码必须明确的通过RNI方法与垃圾收集器交互，而不是依赖于谨慎的垃圾回收器。

在高层，微软Java/COM接口提供一个与语言无关的与Java虚拟机的标准库接口。Java代码可以像使用Java对象一样使用COM的对象，Java类可以像COM类一样被系统其他部分使用。


###宗旨
我们认为一个考虑周全的统一标准接口应该具有以下优点：

-  每一个虚拟机提供商可以支持大规模的本地代码
-  工具开发者不需要维护不同类型的本地方法接口
-  应用开发者只需要一个版本的本地代码，就可以运行在不同版本的虚拟机上

实现标准本地接口的最好方法是使用一个标准统一各种虚拟机的不同。因此我们组织了一系列关于Java许可证的讨论来设计一个统一的本地方法接口。讨论中明确了标准本地方法接口必须满足以下需求：

- 二进制兼容性——主要目标是针对特定平台上的所有Java虚拟机实现都可以兼容二进制的本地方法库。程序员只需要在特定平台上维护一个版本的本地方法库。
- 效率——为了支持要求严格时序的代码，本地方法接口必须减少开销。所有为了实现与虚拟机无关（包括二进制兼容性）的已知技术都要求非常多的开销。我们必须通过某种方式平衡虚拟机无关性和效率。
- 功能性——本地代码可以通过接口更多的访问虚拟机内部。

###Java本地接口方法

我们希望采用现有的方法作为标准接口，因为这样程序员在需要学习不同虚拟机的不同接口时，可以最大限度的减少他们的负担。不幸的是，现有的解决方案中没有一个可以完全满足我们的需求。

Netscape的JRI是最接近于我们预想的可移植本地方法接口，而且曾经被用作我们设计的出发点。对JRI熟悉的读者可能会注意到一些相似之处，包括API命名规则，方法和域ID的使用，局部和全局变量的使用等等。尽管我们非常努力，JNI与JRI仍然不能二进制兼容，尽管一个虚拟机可以同时支持JNI和JRI。

微软的Raw Native接口是对JDK 1.0接口的改善，因为它通过一个”不谨慎“的垃圾回收器解决了本地方法的问题。但是RNI仍然不适合作为一个与虚拟机无关的本地方法接口，像JDK一样，RNI本地方法通过C结构体访问Java对象，导致两个问题：

- RNI暴露给本地代码Java内部对象的组织方式。
- 通过C结构体的方式直接访问Java对象，难以有效的实现“写屏障”，而这对高级的垃圾回收算法来说是必须的。

作为一个二进制标准，COM保证了在不同虚拟机上完全的二进制兼容。COM的方法的使用仅仅需要直接调用，而不需要很多的开销。此外在处理动态链接库版本控制的问题上，COM对象是一个很大的提升。

但是，使用COM作为标准的Java本地方法接口受到以下因素的影响：

- 首先，JAVA/COM接口缺少一些必需的功能，比如访问私有域和抛出普通异常。
- 其次，JAVA/COM接口自动的为Java对象提供IUnknown和IDispatch的COM接口，使得本地代码可以访问public的方法和域。不幸的是IDispatch接口没有处理Java方法的重载而且在匹配方法名时是区分大小写的。所有通过IDispatch接口变得可被访问的Java方法，都被包装起来执行动态类型检查和类型强制转换（*coercion，指隐式类型转换，参考[Wiki][]，译者注*），这是由于IDispatch接口是为了弱类型语言（比如Basic）考虑设计的。
- 再次，COM接口的设计允许软件组件（包括成熟的应用程序）一起运行，而不是处理独立的低级函数，我们认为把所有的Java类和底层的本地方法当作软件组件是不合适的。
- 最后，采用COM接口最直接的阻碍是因为它缺少对Unix平台的支持。

尽管Java对象没有像COM对象那样暴露给本地代码，JNI接口本身与COM接口是二进制兼容的。JNI使用与COM相同的跳转表结构和调用规则。这意味着，只要在交叉平台上支持COM，JNI就变成Java虚拟机的一个COM接口。

JNI不是特定JVM平台上唯一的本地方法接口。程序员可以从一个标准的接口收益，并乐于在不同的Java虚拟机上加载他们的本地代码库。在某些情况下，程序员可能不得不使用一些低级的与VM相关的接口来达到高效率的目的。还有一些情况，程序员使用高级接口来编译软件组件。确实，Java环境和组件软件技术更加成熟，但是本地方法会渐渐变得失去意义。

###JNI编程

本地方法程序员应该使用JNI编程。JNI编程使你不需要知道一些无关的事，比如终端用户使用的哪个提供商的VM。只要遵循JNI标准，你就可以使特定的本地方法库运行在特定的虚拟机上。

如果你正在实现一个Java虚拟机，你应该实现JNI。JNI已经经历过时间的考验，而且确实不会对你的虚拟机实现增加额外的开销和限制，包括目标表示，垃圾回收计划等等都没有影响。如果你遇到了我们可能忽视的问题，请反馈给我们。

###改动

在Java SE6.0上，已经被弃用的JDK1_1InitArgs和JDK1_1AttachArgs已经被移除，取而代之的是JavaVMInitArgs和JavaVMAttachArgs 。





[1]:http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502
[Wiki]:http://en.wikipedia.org/wiki/Type_conversion#Explicit_type_conversion
